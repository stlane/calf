{
    "collab_server" : "",
    "contents" : "calf_internal <- function(data,\n                          nMarkers,\n                          randomize  = FALSE,\n                          proportion = NULL,\n                          times,\n                          targetVector = \"binary\",\n                          margin = NULL,\n                          optimize = \"pval\",\n                        #  reverse = FALSE,\n                          verbose = FALSE){\n  # getting rid of global variable warning -------------------------- #\n  x = NULL\n  y = NULL\n  refx = NULL\n  refy = NULL\n\n  if (targetVector == \"real\") optimize <- NULL\n\n  # setting up some initial values -----------------------------------#\n  if (any(apply(data, 2, is.numeric) == FALSE)) {\n    stop(\"CALF ERROR: Data are not numeric. Please check that data were read in correctly.\")\n  }\n\n\n  nVars <- ncol(data) - 1\n  dNeg  <- data[ ,2:ncol(data)]\n  dNeg  <- dNeg * - 1\n  data  <- data.frame(data, dNeg, check.names = FALSE)\n\n  if (nMarkers > nVars){\n    stop(paste0(\"CALF ERROR: Requested number of markers is larger than the number of markers in data set. \",\n                \"Please revise this value or make sure your data were read in properly.\"))\n  }\n\n  if (randomize == TRUE) data[ ,1] <- sample(data[ ,1])\n\n  if (!is.null(proportion)){\n    if (targetVector == \"binary\"){\n      ctrlRows  <- which(data[ ,1] == 0)\n      caseRows  <- which(data[ ,1] == 1)\n      # calculate number of case and control to keep\n      nCtrlKeep <- round(length(ctrlRows)*proportion, digits = 0)\n      nCaseKeep <- round(length(caseRows)*proportion, digits = 0)\n      # sample randomly rows of case and control to keep, record rows to keep\n      keepRows  <- c(sample(ctrlRows)[1:nCtrlKeep], sample(caseRows)[1:nCaseKeep])\n      # subset original data to keep these rows\n      data      <- data[keepRows, ]\n    } else {\n      nDataKeep <- round(nrow(data)*proportion, digits = 0)\n      keepRows  <- sample(1:nrow(data))[1:nDataKeep]\n      data      <- data[keepRows, ]\n    }\n  }\n\n  real  <- data[ ,1]\n  realMarkers <- data[ , 2:ncol(data)]\n  ctrl  <- data[data[ ,1] == 0, 2:ncol(data)]\n  case  <- data[data[ ,1] == 1, 2:ncol(data)]\n  indexNegPos <- rep(0, (nVars*2))\n  # end of setting up some initial values ----------------------------#\n\n  # initial loop to establish first optimal marker -------------------#\n  allCrit <- numeric()\n  for (i in 1:(nVars*2)){\n    if (targetVector == \"binary\"){\n      caseVar    <- case[ ,i]\n      ctrlVar    <- ctrl[ ,i]\n      if (optimize == \"pval\"){\n        crit       <- t.test(caseVar, ctrlVar, var.equal = FALSE)$p.value\n      } else if (optimize == \"auc\"){\n        crit <- compute.auc(caseVar, ctrlVar)\n        crit <- 1/crit\n      }\n    } else {\n      realVar <- realMarkers[ ,i]\n      crit    <- suppressWarnings(cor(real, realVar, use = \"complete.obs\"))\n      crit    <- 1/crit\n    }\n    allCrit[i] <- crit\n  }\n  allCrit[allCrit < 0] <- NA\n\n  # end of initial loop ----------------------------------------------#\n\n  keepMarkers  <- names(realMarkers)[which.min(allCrit)]\n  bestCrit     <- min(allCrit, na.rm = TRUE)\n  keepIndex    <- which.min(allCrit)\n\n if (verbose == TRUE) {\n   if (optimize == \"pval\"){\n   cat(\"Selected:\", keepMarkers,\n       paste0(\"p value = \", round(bestCrit, digits = 15), \"\\n\"))\n   } else if (optimize == \"auc\"){\n     cat(\"Selected:\", keepMarkers,\n         paste0(\"AUC = \", round((1/bestCrit), digits = 15), \"\\n\"))\n   } else if (targetVector == \"real\")\n     cat(\"Selected:\", keepMarkers,\n         paste0(\"Correlation = \", round((1/bestCrit), digits = 15), \"\\n\"))\n }\n\n  # second loop to add another marker --------------------------------#\n  if (nMarkers != 1){\n    allCrit  <- numeric()\n    realPrev <- realMarkers[ ,keepIndex]\n    casePrev <- case[ ,keepIndex]\n    ctrlPrev <- ctrl[ ,keepIndex]\n    for (i in 1:(nVars*2)){\n      if (i != keepIndex){\n        caseVar <- casePrev + case[ ,i]\n        ctrlVar <- ctrlPrev + ctrl[ ,i]\n        realVar <- realPrev + realMarkers[ ,i]\n        if (targetVector == \"binary\"){\n          if (optimize == \"pval\"){\n            crit       <- t.test(caseVar, ctrlVar, var.equal = FALSE)$p.value\n          } else if (optimize == \"auc\"){\n            crit <- compute.auc(caseVar, ctrlVar)\n            crit <- 1/crit\n          }\n        } else {\n          crit <- suppressWarnings(cor(real, realVar, use = \"complete.obs\"))\n          crit <- 1/crit\n        }\n      } else {\n        crit <- NA\n      }\n      allCrit[i] <- crit\n    }\n    # end of second loop ----------------------------------------------#\n\n    allCrit[allCrit < 0] <- NA\n\n    # check if the latest p is lower than the previous p               #\n    continue <- ifelse(bestCrit[length(bestCrit)] > min(allCrit, na.rm = TRUE), TRUE, FALSE)\n\n    if (!is.null(margin)){\n      diffCrit <- 1/min(allCrit, na.rm = TRUE) - 1/bestCrit\n      continue <- ifelse(diffCrit >= margin, TRUE, FALSE)\n    }\n\n    if (continue == TRUE){\n      keepMarkers  <- append(keepMarkers, names(realMarkers)[which.min(allCrit)])\n      bestCrit     <- append(bestCrit, min(allCrit, na.rm = TRUE))\n      keepIndex    <- append(keepIndex, which.min(allCrit))\n\n      if (length(keepMarkers) == nMarkers) continue <- FALSE\n    }\n\n    if (verbose == TRUE) {\n      if (optimize == \"pval\"){\n        cat(\"Selected:\", keepMarkers[length(keepMarkers)],\n            paste0(\"p value = \", round(bestCrit[length(bestCrit)], digits = 15), \"\\n\"))\n      } else if (optimize == \"auc\"){\n        cat(\"Selected:\", keepMarkers[length(keepMarkers)],\n            paste0(\"AUC = \", round((1/bestCrit[length(bestCrit)]), digits = 15), \"\\n\"))\n      } else if (targetVector == \"real\")\n        cat(\"Selected:\", keepMarkers[length(keepMarkers)],\n            paste0(\"Correlation = \", round((1/bestCrit[length(bestCrit)]), digits = 15), \"\\n\"))\n    }\n\n    # loop for third through nMarker ----------------------------------#\n    while (continue == TRUE){\n      allCrit  <- numeric()\n      casePrev <- rowSums(case[ ,keepIndex], na.rm = TRUE)\n      ctrlPrev <- rowSums(ctrl[ ,keepIndex], na.rm = TRUE)\n      realPrev <- rowSums(realMarkers[ ,keepIndex], na.rm = TRUE)\n      for (i in 1:(nVars*2)){\n        if (!(i %in% keepIndex)){\n          caseVar <- casePrev + case[ ,i]\n          ctrlVar <- ctrlPrev + ctrl[ ,i]\n          realVar <- realPrev + realMarkers[ ,i]\n          if (targetVector == \"binary\"){\n            if (optimize == \"pval\"){\n              crit       <- t.test(caseVar, ctrlVar, var.equal = FALSE)$p.value\n            } else if (optimize == \"auc\"){\n              crit <- compute.auc(caseVar, ctrlVar)\n              crit <- 1/crit\n            }\n          } else {\n            crit <- suppressWarnings(cor(real, realVar, use = \"complete.obs\"))\n            crit <- 1/crit\n          }\n        } else {\n          crit <- NA\n        }\n        allCrit[i] <- crit\n      }\n      allCrit[allCrit < 0] <- NA\n\n      continue <- ifelse(bestCrit[length(bestCrit)] > min(allCrit, na.rm = TRUE),\n                         TRUE, FALSE)\n\n      if (!is.null(margin)){\n        diffCrit <- 1/min(allCrit, na.rm = TRUE) - 1/bestCrit\n        continue <- ifelse(diffCrit >= margin, TRUE, FALSE)\n      }\n\n      if (continue == TRUE){\n        keepMarkers  <- append(keepMarkers, names(realMarkers)[which.min(allCrit)])\n        bestCrit     <- append(bestCrit, min(allCrit, na.rm = TRUE))\n        keepIndex    <- append(keepIndex, which.min(allCrit))\n        continue     <- bestCrit[length(bestCrit)] < bestCrit[length(bestCrit)-1]\n        if (verbose == TRUE) {\n          if (optimize == \"pval\"){\n            cat(\"Selected:\", keepMarkers[length(keepMarkers)],\n                paste0(\"p value = \", round(bestCrit[length(bestCrit)], digits = 15), \"\\n\"))\n          } else if (optimize == \"auc\"){\n            cat(\"Selected:\", keepMarkers[length(keepMarkers)],\n                paste0(\"AUC = \", round((1/bestCrit[length(bestCrit)]), digits = 15), \"\\n\"))\n          } else if (targetVector == \"real\")\n            cat(\"Selected:\", keepMarkers[length(keepMarkers)],\n                paste0(\"Correlation = \", round((1/bestCrit[length(bestCrit)]), digits = 15), \"\\n\"))\n        }\n      }\n\n      # NEW PRUNING PROCEDURE, tabled on 05 19 2017 ---------------------------------#\n      # drop markers one at a time, making sure that dropping that marker\n      # does not result in an improvement in the score metric\n      # if (reverse == TRUE){\n      #   storeCrits <- numeric()\n      #   for (j in 1:length(keepIndex)){\n      #     if (optimize == \"pval\"){\n      #       crit <- t.test(rowSums(case[ ,keepIndex]) - case[ ,keepIndex[j]],\n      #                      rowSums(ctrl[ ,keepIndex]) - ctrl[ ,keepIndex[j]],\n      #                      var.equal = FALSE)$p.value\n      #       storeCrits[j] <- crit\n      #     }\n      #\n      #     if (optimize == \"auc\"){\n      #       crit <- compute.auc(rowSums(case[ ,keepIndex]) - case[ ,keepIndex[j]],\n      #                           rowSums(ctrl[ ,keepIndex]) - ctrl[ ,keepIndex[j]])\n      #       crit <- 1/crit\n      #       storeCrits[j] <- crit\n      #     }\n      #\n      #     if (targetVector == \"real\"){\n      #       crit <- suppressWarnings(cor(real,\n      #                                    rowSums(realMarkers[ ,keepIndex], na.rm = TRUE) -\n      #                                      realMarkers[ ,keepIndex[j]] ,\n      #                                    use = \"complete.obs\"))\n      #       crit <- 1/crit\n      #       storeCrits[j] <- crit\n      #     }\n      #   }\n      #   # drop the marker that improved the crit when it was dropped\n      #   # drop the one that dropped it the most in the case of multiple markers\n      #   drop <- keepIndex[which.min(storeCrits[which(storeCrits < bestCrit[length(bestCrit)])])]\n      #   if (length(drop) != 0){\n      #     bestCrit                   <- bestCrit[-length(bestCrit)]\n      #     bestCrit[length(bestCrit)] <- min(storeCrits)\n      #     keepIndex                  <- keepIndex[!keepIndex %in% drop]\n      #     keepMarkers                <- keepMarkers[!keepMarkers %in% names(realMarkers)[drop]]\n      #\n      #     if (verbose == TRUE) {\n      #       if (optimize == \"pval\"){\n      #         cat(\"Dropped:\", names(realMarkers)[drop],\n      #             paste0(\"new p value = \", round(bestCrit[length(bestCrit)], digits = 15), \"\\n\"))\n      #       } else if (optimize == \"auc\"){\n      #         cat(\"Dropped:\", names(realMarkers)[drop],\n      #             paste0(\"new AUC = \", round((1/bestCrit[length(bestCrit)]), digits = 15), \"\\n\"))\n      #       } else if (targetVector == \"real\")\n      #         cat(\"Dropped:\", names(realMarkers)[drop],\n      #             paste0(\"Correlation = \", round((1/bestCrit[length(bestCrit)]), digits = 15), \"\\n\"))\n      #     }\n      #   }\n      #   # END PRUNING PROCEDURE ----------------------------------------------#\n      #   # stop the search when it hits the max number of markers\n      # }\n      if (length(keepMarkers) == nMarkers) continue <- FALSE\n    }\n  }\n\n  if (verbose == TRUE) cat(\"\\n\")\n\n  indexNegPos[keepIndex] <- ifelse(keepIndex >= nVars, -1, 1)\n  finalIndex   <- ifelse(keepIndex <= nVars, keepIndex, keepIndex - nVars)\n  finalMarkers <- data.frame(names(case)[finalIndex], indexNegPos[keepIndex], check.names = FALSE)\n  names(finalMarkers) <- c(\"Marker\",\"Weight\")\n\n  if (targetVector == \"real\" | optimize == \"auc\") {\n    finalBestCrit <- 1 / bestCrit[length(bestCrit)]\n  } else {\n    finalBestCrit <- bestCrit[length(bestCrit)]\n  }\n  ## AUC -------------------------------------------------------------#\n  # create function value for each individual\n  if (targetVector == \"binary\"){\n    if (nMarkers != 1 & length(keepIndex) != 1){\n      funcValue   <- c(rowSums(case[,c(keepIndex)]), rowSums(ctrl[,c(keepIndex)]))\n    } else {\n      funcValue   <- c(case[,c(keepIndex)], ctrl[,c(keepIndex)])\n    }\n    funcValue <- round(funcValue, digits = 8)\n    # rank individual function values\n    ranks       <- rank(funcValue, ties.method = \"average\")\n    seqCaseCtrl <- c(rep(1, nrow(case)), rep(0, nrow(ctrl)))\n\n    # set up plot -----------------------------------------------------#\n    all <- data.frame(funcValue,\n                      seqCaseCtrl,\n                      ranks)\n    all <- all[order(all$ranks),]\n    all$refx <- seq(0,1,1/(nrow(all)-1))\n    all$refy <- seq(0,1,1/(nrow(all)-1))\n    initVal  <- all$seqCaseCtrl[1]\n    moveRight <- ifelse(initVal == 0, nrow(case), nrow(ctrl))\n    moveUp    <- ifelse(initVal == 0, nrow(ctrl), nrow(case))\n    # moveLeft\n    for (i in 2:nrow(all)){\n      all$x[1] <- 0\n      all$y[1] <- 0\n      if (all$seqCaseCtrl[i] == initVal){\n        all$x[i] = all$x[i-1]\n        all$y[i] = all$y[i-1] + 1/(moveUp-1)\n      } else {\n        all$x[i] = all$x[i-1] + 1/(moveRight)\n        all$y[i] = all$y[i-1]\n      }\n    }\n\n    # if the plot prints upside-down, switch values for\n    # x and y\n    n <- round(length(all$refy)/2, digits = 0)\n    if (all$refy[n] > all$y[n]){\n      all$a <- all$x\n      all$b <- all$y\n      all$x <- all$b\n      all$y <- all$a\n    }\n\n    rocPlot <- ggplot(all, aes(x = x, y = y)) +\n      geom_line(size = 1) +\n      geom_line(aes(x = refx, y = refy, colour = \"red\"), size = 1.5) +\n      scale_x_continuous(limits = c(0,1)) +\n      theme_bw() +\n      theme(legend.position = \"none\") +\n      ylab(\"True Positive Rate (Sensitivity)\") +\n      xlab(\"False Positive Rate (1 - Specificity)\")\n    # set up plot -----------------------------------------------------#\n\n    # compute arguments for AUC\n    caseFunc  <- sum(ranks[1:nrow(case)]) - nrow(case)*(nrow(case)+1)/2\n    ctrlFunc  <- sum(ranks[(nrow(case)+1):length(ranks)]) - nrow(ctrl)*(nrow(ctrl)+1)/2\n    # compute AUC\n    auc       <- round(max(ctrlFunc, caseFunc)/(caseFunc + ctrlFunc), digits = 4)\n  } else {\n    auc     <- NULL\n    rocPlot <- NULL\n  }\n  est       <- list(selection  = finalMarkers,\n                    auc        = auc,\n                    randomize  = randomize,\n                    proportion = proportion,\n                    targetVec  = targetVector,\n                    rocPlot    = rocPlot,\n                    finalBest  = finalBestCrit,\n                    optimize   = optimize)\n  class(est) <- \"calf\"\n  return(est)\n}\n\ncompute.auc <- function(caseVar, ctrlVar){\n  funcValue <- c(caseVar, ctrlVar)\n  funcValue <- round(funcValue, digits = 8)\n  ranks     <- rank(funcValue, ties.method = \"average\")\n  caseFunc  <- sum(ranks[1:length(caseVar)]) - length(caseVar)*(length(caseVar)+1)/2\n  ctrlFunc  <- sum(ranks[(length(caseVar)+1):length(ranks)]) - length(ctrlVar)*(length(ctrlVar)+1)/2\n  auc       <- round(max(ctrlFunc, caseFunc)/(caseFunc + ctrlFunc), digits = 4)\n  return(auc)\n}\n\n",
    "created" : 1493319016906.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1431784672",
    "id" : "723A7E5B",
    "lastKnownWriteTime" : 1495205035,
    "last_content_update" : 1495205035321,
    "path" : "C:/Users/stlane/Dropbox/Current Consulting/clark jeffries/CALF/calf_git/R/calf_internal.R",
    "project_path" : "R/calf_internal.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}